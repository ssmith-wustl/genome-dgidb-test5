use strict; use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use above "Genome";
use Data::Dumper;
use Test::More tests => 41;
use_ok('Genome::Model::Build::ReferenceSequence');

# create a test annotation build and a few reference sequence builds to test compatibility with
my @species_names = ('human', 'mouse');
my @versions = (1, 2, 3);
my $data_dir = File::Temp::tempdir('ImportedAnnotationTest-XXXXX', DIR => '/gsc/var/cache/testsuite/running_testsuites', CLEANUP => 1);

my %samples;
for my $sn (@species_names) {
    my $p = Genome::Individual->create(name => "test-$sn-patient", common_name => 'testpatient');
    my $s = Genome::Sample->create(name => "test-$sn-patient", species_name => $sn, common_name => 'tumor', source => $p);
    ok($s, 'created sample');
    $samples{$sn} = $s;
}
my %rbuilds = create_reference_builds(\@species_names, \@versions);

# 1 -> 2
$rbuilds{'human'}[1]->derived_from($rbuilds{'human'}[0]);
ok(!$rbuilds{'human'}[0]->is_compatible_with(), 'build is not compatible with null');
ok($rbuilds{'human'}[0]->is_derived_from($rbuilds{'human'}[0]), 'build is derived from itself');
ok($rbuilds{'human'}[0]->is_compatible_with($rbuilds{'human'}[0]), 'build is compatible with itself');
ok($rbuilds{'human'}[0]->is_derived_from($rbuilds{'human'}[0]), 'build w/no parent gets coordinates_from itself');
ok($rbuilds{'human'}[1]->is_derived_from($rbuilds{'human'}[0]), 'build is derived from its parent');
ok($rbuilds{'human'}[1]->is_derived_from($rbuilds{'human'}[0]), 'build is compatible with its parent');
is($rbuilds{'human'}[1]->get_coordinates_from(), $rbuilds{'human'}[0], 'build w/1 lvl of parent gets coordinates_from parent');
ok(!$rbuilds{'human'}[0]->is_derived_from($rbuilds{'human'}[1]), 'build is not derived from its descendant');
ok($rbuilds{'human'}[0]->is_compatible_with($rbuilds{'human'}[1]), 'build is compatible with its child');

# 1 -> 2 -> 3
$rbuilds{'human'}[2]->derived_from($rbuilds{'human'}[1]);
ok($rbuilds{'human'}[2]->is_derived_from($rbuilds{'human'}[0]), 'build is derived from grandparent');
ok($rbuilds{'human'}[2]->is_compatible_with($rbuilds{'human'}[0]), 'build is compatible with its grandparent');
ok($rbuilds{'human'}[0]->is_compatible_with($rbuilds{'human'}[2]), 'build is compatible with its grandchild');
is($rbuilds{'human'}[2]->get_coordinates_from(), $rbuilds{'human'}[0], 'build w/2 lvl of parent gets coordinates_from grandparent');

# attempt to derive from another model's build
ok(!$rbuilds{'human'}[0]->__errors__, "no errors so far...");
$rbuilds{'human'}[0]->derived_from($rbuilds{'mouse'}[0]);
my @errs = $rbuilds{'human'}[0]->__errors__;
ok(@errs, "deriving from another model's build is an error");
ok($errs[0]->type, 'error type is correct');
is($errs[0]->{properties}->[0], 'derived_from', 'error references derived_from property');

# attempt to derive from self
ok(!$rbuilds{'human'}[1]->__errors__, "no errors so far...");
$rbuilds{'human'}[1]->derived_from($rbuilds{'human'}[1]);
@errs = $rbuilds{'human'}[1]->__errors__;
ok(@errs, "deriving from self is an error");
ok($errs[0]->type, 'error type is correct');
is($errs[0]->{properties}->[0], 'derived_from', 'error references derived_from property');

# set up circular link
$rbuilds{'human'}[0]->derived_from($rbuilds{'human'}[1]);
$rbuilds{'human'}[1]->derived_from($rbuilds{'human'}[0]);
@errs = $rbuilds{'human'}[1]->__errors__();
ok(@errs, "circular links are reported in __errors__()");
is($errs[0]->{properties}->[0], 'derived_from', 'error references derived_from property');
like($errs[0]->{desc}, '/Circular/', 'error mentions "circular"');
eval { $rbuilds{'human'}[1]->is_derived_from($rbuilds{'human'}[3]); };
ok($@, 'circular links are detected in is_derived_from');
eval { $rbuilds{'human'}[1]->get_coordinates_from(); };
ok($@, 'circular links are detected in coordinates from');

map { $_->derived_from(undef) } @{$rbuilds{'human'}}; #reset
$rbuilds{'human'}[1]->coordinates_from($rbuilds{'human'}[0]);
is($rbuilds{'human'}[0], $rbuilds{'human'}[0]->get_coordinates_from($rbuilds{'human'}[0]), 'get_coordinates_from works');
is($rbuilds{'human'}[0], $rbuilds{'human'}[1]->get_coordinates_from($rbuilds{'human'}[0]), 'get_coordinates_from works');
ok($rbuilds{'human'}[1]->is_compatible_with($rbuilds{'human'}[0]), 'build is_compatible with build->coordinates_from');
ok($rbuilds{'human'}[0]->is_compatible_with($rbuilds{'human'}[1]), 'build is_compatible with things that list it as coordinates_from');

done_testing();

sub create_reference_builds {
    my ($species_names, $versions) = @_;
    my %rbuilds;
    my $ref_pp = Genome::ProcessingProfile::ImportedReferenceSequence->create(name => 'test_ref_pp');
    for my $sn (@$species_names) {
        $rbuilds{$sn} = [];

        my $ref_model = Genome::Model::ReferenceSequence->create(
            name                => "test_ref_sequence_$sn",
            processing_profile  => $ref_pp,
            subject_class_name  => ref($samples{$sn}),
            subject_id          => $samples{$sn}->id,
        );
        ok($ref_model, "created reference sequence model ($sn)");

        for my $v (@$versions) {
            my $rs = Genome::Model::Build::ReferenceSequence->create(
                name            => "ref_sequence_${sn}_$v",
                model           => $ref_model,
                fasta_file      => 'nofile',
                data_directory  => $data_dir,
                version         => $v,
                );
            ok($rs, "created ref seq build $sn $v");
            push(@{$rbuilds{$sn}}, $rs);
        }
    }
    return %rbuilds;
}
