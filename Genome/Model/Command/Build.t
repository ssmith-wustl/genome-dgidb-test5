#!/gsc/bin/perl

use strict;
use warnings;

use File::Temp;
use Test::More tests => 28;

use above 'Genome';

require_ok('Genome::Model::Command::Build');
BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

my $user_interactive_mode = 0;

my $bogus_id = -10000;
my $tmp_dir = File::Temp::tempdir(CLEANUP => 1);

my $pp = Genome::ProcessingProfile::ReferenceAlignment->create_mock(
                                                                    id => $bogus_id,
                                                                    processing_profile_id => $bogus_id,
                                                                    name => 'test',
                                                                    dna_type => 'genomic dna',
                                                                    read_aligner_name => 'maq0_6_8',
                                                                    sequencing_platform => 'solexa',
                                                                    reference_sequence_name => 'refseq-for_test',
                                                                    type_name => 'reference alignment',
                                                                );
isa_ok($pp,'Genome::ProcessingProfile');
$pp->set_list('stages',[]);
$pp->set_list('objects_for_stage',[]);

my $model_wo_instrument_data = Genome::Model::ReferenceAlignment->create_mock(
                                                           id => --$bogus_id,
                                                           genome_model_id => $bogus_id,
                                                           subject_type => 'sample_name',
                                                           subject_name => 'test_sample_name',
                                                           processing_profile_id => $pp->id,
                                                           name => 'test',
                                                           data_directory => $tmp_dir,
                                                           instrument_data => [],
                                                           type_name => $pp->type_name,
                                                           sequencing_platform => $pp->sequencing_platform,
                                                           processing_profile => $pp
                                                       );
isa_ok($model_wo_instrument_data,'Genome::Model');
$model_wo_instrument_data->mock('builds', \&Genome::Model::builds);
$model_wo_instrument_data->mock('running_builds', \&Genome::Model::running_builds);
$model_wo_instrument_data->mock('instrument_data_assignments', \&Genome::Model::instrument_data_assignments);
$model_wo_instrument_data->mock('instrument_data', \&Genome::Model::instrument_data);
$model_wo_instrument_data->mock('inputs', \&Genome::Model::inputs);

# The call to Solexa->create() below is expected to fail.
my $build_wo_reads = Genome::Model::Command::Build::ReferenceAlignment->create(model => $model_wo_instrument_data);
ok(!$build_wo_reads,'build should fail create with no read sets');

my $mock_pp = Genome::ProcessingProfile::Staged->create_mock(
                                                     id => --$bogus_id,
                                                     name => 'test_pp_name',
                                                     type_name => 'abstract base test',
                                                 );
isa_ok($mock_pp,'Genome::ProcessingProfile');
$mock_pp->set_list('stages','stage1','stage2');
$mock_pp->set_list('stage1_job_classes',
                   'Genome::Model::Command::Build::AbstractBaseTest::StageOneJobOne',
                   'Genome::Model::Command::Build::AbstractBaseTest::StageOneJobTwo',
                   'Genome::Model::Command::Build::AbstractBaseTest::StageOneJobThree',
               );
$mock_pp->set_list('stage2_job_classes',
                   'Genome::Model::Command::Build::AbstractBaseTest::StageTwoJobOne',
                   'Genome::Model::Command::Build::AbstractBaseTest::StageTwoJobTwo',
               );
$mock_pp->mock('classes_for_stage',\&Genome::ProcessingProfile::Staged::classes_for_stage);
$mock_pp->mock('objects_for_stage',\&Genome::ProcessingProfile::Staged::objects_for_stage);
$mock_pp->mock('verify_successful_completion_objects',\&Genome::ProcessingProfile::verify_successful_completion_objects);
$mock_pp->mock('verify_successful_completion_job_classes',\&Genome::ProcessingProfile::verify_successful_completion_job_classes);

my $mock_model = Genome::Model->create_mock(
                                            id => --$bogus_id,
                                            genome_model_id => $bogus_id,
                                            subject_type => 'test_subject_type',
                                            subject_name => 'test_sample_name',
                                            processing_profile_id => $mock_pp->id,
                                            name => 'test_w_instrument_data',
                                            data_directory => $tmp_dir,
                                            latest_build_directory => $tmp_dir,
                                            type_name => $mock_pp->type_name,
                                            processing_profile => $mock_pp,
                                        );
isa_ok($mock_model,'Genome::Model');
$mock_model->mock('builds', \&Genome::Model::builds);
$mock_model->mock('running_builds', \&Genome::Model::running_builds);
$mock_model->mock('instrument_data_assignments', \&Genome::Model::instrument_data_assignments);
$mock_model->mock('instrument_data', \&Genome::Model::instrument_data);
$mock_model->mock('inputs', \&Genome::Model::inputs);

my @instrument_data;
for (1 .. 10) {
    my $instrument_data = Genome::InstrumentData->create_mock(
                                                        seq_id => --$bogus_id,
                                                        id => $bogus_id,
                                                        sample_name => 'test_sample_name',
                                                        sequencing_platform => 'test_sequence_platform',
                                                    );
    $instrument_data->set_always('class', 'Genome::InstrumentData');
    push @instrument_data, $instrument_data;
}
$mock_model->set_list('instrument_data',@instrument_data);
$mock_pp->set_list('stage1_objects',@instrument_data);
my @idas;
for my $instrument_data ($mock_model->instrument_data) {
    my $ida = Genome::Model::InstrumentDataAssignment->create_mock(
                                                                   instrument_data_id => $instrument_data->id,
                                                                   model_id => $mock_model->id,
                                                                   id => $instrument_data->id .' '.$mock_model->id,
                                                               );
    push @idas, $ida;
}
$mock_model->set_list('instrument_data_assignments',@idas);

my @ref_seqs;
for (1 .. 5) {
    my $ref_seq = Genome::Model::RefSeq->create_mock(
                                                     id => --$bogus_id,
                                                     model_id => $mock_model->id,
                                                     ref_seq_name => $_,
                                                     ref_seq_id => $bogus_id,
                                                 );
    push @ref_seqs, $ref_seq;
}
$mock_model->set_list('ref_seqs',@ref_seqs);
$mock_pp->set_list('stage2_objects',@ref_seqs);

my $abstract_build = Genome::Model::Command::Build::AbstractBaseTest->create(
                                                                             model => $mock_model,
                                                                             auto_execute => 0,
                                                                         );
isa_ok($abstract_build,'Genome::Model::Command::Build::AbstractBaseTest');

$abstract_build->dump_error_messages($user_interactive_mode);
$abstract_build->dump_warning_messages($user_interactive_mode);
$abstract_build->dump_status_messages($user_interactive_mode);
$abstract_build->queue_error_messages(1);
$abstract_build->queue_warning_messages(1);
$abstract_build->queue_status_messages(1);

is(scalar($mock_pp->stages),2,'two stages for abstract build');
is(scalar($mock_pp->stage1_objects),10,'ten objects for stage 1');
is(scalar($mock_pp->stage2_objects),5,'five objects for stage 2');
ok($abstract_build->execute,'execute '. $abstract_build->command_name);
is(scalar(grep { /^Scheduling for Test::MockObject with id .*/ } $abstract_build->status_messages),15,
          'found fifteen status messages for scheduling mock objects');
is(scalar(grep { /^Scheduled Genome::Model::Command::Build::AbstractBaseTest::StageOne.*/ } $abstract_build->status_messages),30,
          'found thirty status messages for stage1');
is(scalar(grep { /^Scheduled Genome::Model::Command::Build::AbstractBaseTest::StageTwo.*/ } $abstract_build->status_messages),10,
          'found ten status messages for stage2');
ok(!$abstract_build->abandon_incomplete_events_for_stage('stage1',0),'do not abandon incomplete events');
ok(scalar(grep { /^Found 30 incomplete events for stage stage1:/ } $abstract_build->status_messages),'found status message about thirty incomplete events for stage1');


my @stage1_events = $abstract_build->events_for_stage('stage1');
my $fail_count = int((scalar(@stage1_events) * .05));
my %fail_indices;
if ($fail_count > 0) {
    for (1 .. $fail_count) {
        my $index;
        while (1) {
            $index = int(rand(scalar(@stage1_events)));
            last if !defined($fail_indices{$index});
        }
        $fail_indices{$index} = 1;
    }
}
for (my $i = 0; $i < scalar(@stage1_events); $i++) {
    my $event = $stage1_events[$i];
    if (defined($fail_indices{$i})) {
        $event->event_status('Failed');
        $event->date_completed(UR::Time->now);
    } else {
        $event->event_status('Succeeded');
        $event->date_completed(UR::Time->now);
    }
}
ok($abstract_build->abandon_incomplete_events_for_stage('stage1',1),'abandon incomplete events');
ok(scalar(grep{ $_->event_status eq 'Abandoned' } @stage1_events),'found abandoned event');
ok(!$abstract_build->continue_with_abandoned_events_for_stage('stage1',0),'do not continue with abandoned events');
ok($abstract_build->continue_with_abandoned_events_for_stage('stage1',1),'continue with abandoned events');
ok(!$abstract_build->ignore_unverified_events_for_stage('stage1',0),'do not ignore unverified events');
ok($abstract_build->ignore_unverified_events_for_stage('stage1',1),'ignore unverified events');
ok(!$abstract_build->verify_successful_completion_for_stage('stage1',0),'do not continue with unsuccessful events');
ok($abstract_build->verify_successful_completion_for_stage('stage1',1),'continue with unsuccessful events');

my $ret;
eval {
    $ret = $abstract_build->_ask_user_question('This should return undef?',1);
};
ok(!$ret,'user question defaults to undef after one second');

SKIP: {
    skip 'this test requires user interaction', 3 unless $user_interactive_mode;
    $abstract_build->dump_status_messages(1);
    my $invalid_ret;
    eval {
        $invalid_ret = $abstract_build->_ask_user_question("If you want to pass this test then reply 'blah' NOW...");
    };
    ok(!$invalid_ret,'invalid user response is working');
    is($abstract_build->_ask_user_question("If you want to pass this test then reply 'yes' NOW...."),'yes','user replied yes');
    is($abstract_build->_ask_user_question("If you want to pass this test then reply 'no' NOW...."),'no','user replied no');
};

exit;

